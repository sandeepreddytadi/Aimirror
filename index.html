<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Avatar Mirror</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .container {
            display: flex;
            gap: 30px;
            max-width: 1400px;
            width: 100%;
            align-items: flex-start;
        }

        .video-section {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .avatar-section {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .section-title {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            color: #fff;
        }

        #videoElement {
            width: 100%;
            height: 400px;
            border-radius: 15px;
            object-fit: cover;
            border: 2px solid rgba(255, 255, 255, 0.3);
            transform: scaleX(-1);
            background: #2d3748;
        }

        #avatarCanvas {
            width: 100%;
            height: 400px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: radial-gradient(circle at center, #4a5568 0%, #2d3748 100%);
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #4834d4, #686de0);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #00d2d3, #54a0ff);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            margin-top: 15px;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .status.loading {
            background: rgba(255, 193, 7, 0.2);
            border-color: rgba(255, 193, 7, 0.5);
            color: #ffc107;
        }

        .status.active {
            background: rgba(40, 167, 69, 0.2);
            border-color: rgba(40, 167, 69, 0.5);
            color: #28a745;
        }

        .status.error {
            background: rgba(220, 53, 69, 0.2);
            border-color: rgba(220, 53, 69, 0.5);
            color: #dc3545;
        }

        .pose-info {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .confidence-bar {
            background: rgba(255, 255, 255, 0.2);
            height: 8px;
            border-radius: 4px;
            margin-top: 10px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(45deg, #00d2d3, #54a0ff);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                gap: 20px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            #videoElement, #avatarCanvas {
                height: 300px;
            }
            
            .controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .btn {
                padding: 15px 20px;
                font-size: 1.1em;
                width: 100%;
            }
        }

        /* Mobile-specific styles */
        @media (max-width: 480px) {
            body {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 1.8em;
            }
            
            .video-section, .avatar-section {
                padding: 15px;
            }
            
            #videoElement, #avatarCanvas {
                height: 250px;
            }
            
            .section-title {
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ü§ñ AI Avatar Mirror</h1>
        <p>Your movements, reflected in real-time through AI pose detection</p>
    </div>

    <div class="container">
        <div class="video-section">
            <h2 class="section-title">üìπ Camera Feed</h2>
            <video id="videoElement" autoplay muted playsinline></video>
            <div class="controls">
                <button id="startBtn" class="btn btn-primary">Start Camera</button>
                <button id="stopBtn" class="btn btn-secondary" disabled>Stop Camera</button>
            </div>
            <div id="videoStatus" class="status">Click "Start Camera" to begin</div>
            <div class="troubleshooting" style="margin-top: 15px; padding: 15px; background: rgba(255, 255, 255, 0.1); border-radius: 10px; font-size: 0.9em; line-height: 1.4; display: none;">
                <strong>üîß Universal Camera Troubleshooting:</strong><br>
                <strong>All Devices:</strong><br>
                ‚Ä¢ Use HTTPS (not HTTP) - camera requires secure connection<br>
                ‚Ä¢ Allow camera permission when browser asks<br>
                ‚Ä¢ Close other apps/tabs using camera<br>
                ‚Ä¢ Try refreshing the page<br>
                <br>
                <strong>üì± Mobile (Android/iOS):</strong><br>
                ‚Ä¢ Use Chrome, Firefox, or Safari<br>
                ‚Ä¢ Check app permissions in device settings<br>
                ‚Ä¢ Clear browser cache and try again<br>
                <br>
                <strong>üíª Desktop (Windows/Mac):</strong><br>
                ‚Ä¢ Check browser camera settings<br>
                ‚Ä¢ Look for camera icon in address bar<br>
                ‚Ä¢ System camera permissions may be blocked<br>
                <br>
                <strong>üåê Browser-Specific:</strong><br>
                ‚Ä¢ Chrome: chrome://settings/content/camera<br>
                ‚Ä¢ Firefox: about:preferences#privacy<br>
                ‚Ä¢ Safari: Safari ‚Üí Preferences ‚Üí Websites ‚Üí Camera
            </div>
        </div>

        <div class="avatar-section">
            <h2 class="section-title">üé≠ AI Avatar</h2>
            <canvas id="avatarCanvas"></canvas>
            <div class="controls">
                <button id="togglePoseBtn" class="btn btn-success" disabled>Start Pose Detection</button>
            </div>
            <div id="poseStatus" class="status">Camera needed for pose detection</div>
            <div id="poseInfo" class="pose-info" style="display: none;">
                <div>Pose Confidence: <span id="poseConfidence">0%</span></div>
                <div class="confidence-bar">
                    <div id="confidenceFill" class="confidence-fill" style="width: 0%"></div>
                </div>
                <div style="margin-top: 10px;">
                    <div>Keypoints Detected: <span id="keypointsCount">0</span>/17</div>
                    <div>Avatar Status: <span id="avatarStatus">Idle</span></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/3.18.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/3.18.0/tf-backend-webgl.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow-models/0.0.2/posenet/posenet.min.js"></script>

    <script>
        class AvatarMirror {
            constructor() {
                this.video = document.getElementById('videoElement');
                this.canvas = document.getElementById('avatarCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.net = null;
                this.isDetecting = false;
                this.animationId = null;
                this.stream = null;
                
                this.setupCanvas();
                this.setupEventListeners();
                this.setupAvatar();
                this.checkBrowserSupport();
            }

            checkBrowserSupport() {
                const isSupported = navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
                const isSecure = location.protocol === 'https:' || location.hostname === 'localhost';
                
                if (!isSupported) {
                    this.updateStatus('videoStatus', 'Camera API not supported in this browser', 'error');
                    document.getElementById('startBtn').disabled = true;
                    return;
                }
                
                if (!isSecure) {
                    this.updateStatus('videoStatus', 'Camera requires HTTPS or localhost', 'error');
                    document.getElementById('startBtn').disabled = true;
                    return;
                }
                
                this.updateStatus('videoStatus', 'Ready to start camera');
            }

            setupCanvas() {
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                
                // Adjust canvas size on window resize
                window.addEventListener('resize', () => {
                    this.canvas.width = this.canvas.offsetWidth;
                    this.canvas.height = this.canvas.offsetHeight;
                    this.drawAvatar();
                });
            }

            setupEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => this.startCamera());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopCamera());
                document.getElementById('togglePoseBtn').addEventListener('click', () => this.togglePoseDetection());
            }

            setupAvatar() {
                this.avatar = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height / 2,
                    poses: null,
                    headRadius: 40,
                    bodyHeight: 120,
                    armLength: 60,
                    legLength: 80,
                    color: '#4ECDC4'
                };
                this.drawAvatar();
            }

            async startCamera() {
                try {
                    this.updateStatus('videoStatus', 'Requesting camera access...', 'loading');
                    
                    // Universal camera constraints that work across all platforms
                    const constraints = {
                        video: {
                            facingMode: 'user',
                            width: { min: 320, ideal: 640, max: 1920 },
                            height: { min: 240, ideal: 480, max: 1080 }
                        },
                        audio: false
                    };
                    
                    console.log('Requesting camera access...');
                    
                    // Direct getUserMedia call - this should trigger permission popup
                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    
                    console.log('Camera access granted, stream:', this.stream);
                    
                    // Set up video element
                    this.video.srcObject = this.stream;
                    this.video.autoplay = true;
                    this.video.playsInline = true; // Important for iOS
                    this.video.muted = true;
                    
                    // Wait for video to be ready
                    await this.waitForVideoReady();
                    
                    this.updateStatus('videoStatus', 'Camera active', 'active');
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('togglePoseBtn').disabled = false;
                    this.updateStatus('poseStatus', 'Ready for pose detection');
                    
                } catch (error) {
                    console.error('Camera access error:', error);
                    this.handleCameraError(error);
                }
            }

            waitForVideoReady() {
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('Video loading timeout'));
                    }, 10000);
                    
                    const onCanPlay = () => {
                        clearTimeout(timeout);
                        this.video.removeEventListener('canplay', onCanPlay);
                        this.video.removeEventListener('error', onError);
                        
                        // Force play for mobile browsers
                        this.video.play().then(() => {
                            console.log('Video playing successfully');
                            resolve();
                        }).catch(playError => {
                            console.error('Play error:', playError);
                            // Try without play() - some browsers auto-play
                            resolve();
                        });
                    };
                    
                    const onError = (error) => {
                        clearTimeout(timeout);
                        this.video.removeEventListener('canplay', onCanPlay);
                        this.video.removeEventListener('error', onError);
                        reject(error);
                    };
                    
                    this.video.addEventListener('canplay', onCanPlay);
                    this.video.addEventListener('error', onError);
                    
                    // If video is already ready
                    if (this.video.readyState >= 2) {
                        onCanPlay();
                    }
                });
            }

            handleCameraError(error) {
                let errorMessage = 'Camera access failed';
                let suggestions = [];
                
                switch (error.name) {
                    case 'NotAllowedError':
                        errorMessage = 'Camera permission denied';
                        suggestions = [
                            'Click "Allow" when browser asks for camera permission',
                            'Check browser address bar for camera icon and allow',
                            'Clear browser permissions and try again',
                            'Make sure no other app is using the camera'
                        ];
                        break;
                        
                    case 'NotFoundError':
                        errorMessage = 'No camera found';
                        suggestions = [
                            'Make sure your device has a camera',
                            'Check if camera is properly connected',
                            'Try refreshing the page',
                            'Check device camera permissions'
                        ];
                        break;
                        
                    case 'NotReadableError':
                        errorMessage = 'Camera is busy';
                        suggestions = [
                            'Close other apps using the camera',
                            'Restart your browser',
                            'Check if another tab is using camera',
                            'Try again in a few seconds'
                        ];
                        break;
                        
                    case 'OverconstrainedError':
                        errorMessage = 'Camera constraints not supported';
                        suggestions = [
                            'Your camera may not support the requested settings',
                            'Trying with basic settings...'
                        ];
                        this.tryBasicCamera();
                        return;
                        
                    case 'NotSupportedError':
                        errorMessage = 'Camera not supported in this browser';
                        suggestions = [
                            'Try Chrome, Firefox, Safari, or Edge',
                            'Update your browser to latest version',
                            'Use HTTPS instead of HTTP'
                        ];
                        break;
                        
                    default:
                        if (error.message.includes('Permission denied')) {
                            errorMessage = 'Camera permission denied';
                            suggestions = [
                                'Look for camera permission popup',
                                'Check browser address bar for camera icon',
                                'Allow camera access when prompted'
                            ];
                        } else if (error.message.includes('secure')) {
                            errorMessage = 'Secure connection required';
                            suggestions = [
                                'Use HTTPS instead of HTTP',
                                'Camera requires secure connection'
                            ];
                        }
                }
                
                this.updateStatus('videoStatus', errorMessage, 'error');
                this.showTroubleshootingSteps(suggestions);
            }

            async tryBasicCamera() {
                try {
                    console.log('Trying basic camera constraints...');
                    this.updateStatus('videoStatus', 'Trying basic camera settings...', 'loading');
                    
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        video: true,
                        audio: false
                    });
                    
                    this.video.srcObject = this.stream;
                    this.video.autoplay = true;
                    this.video.playsInline = true;
                    this.video.muted = true;
                    
                    await this.waitForVideoReady();
                    
                    this.updateStatus('videoStatus', 'Camera active (basic mode)', 'active');
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('togglePoseBtn').disabled = false;
                    this.updateStatus('poseStatus', 'Ready for pose detection');
                    
                } catch (basicError) {
                    console.error('Basic camera also failed:', basicError);
                    this.handleCameraError(basicError);
                }
            }

            showTroubleshootingSteps(suggestions) {
                const troubleshootingDiv = document.querySelector('.troubleshooting');
                if (troubleshootingDiv && suggestions.length > 0) {
                    const stepsList = suggestions.map(step => `‚Ä¢ ${step}`).join('<br>');
                    troubleshootingDiv.innerHTML = `<strong>üí° Try these steps:</strong><br>${stepsList}`;
                    troubleshootingDiv.style.display = 'block';
                }
            }

            stopCamera() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => {
                        track.stop();
                        console.log('Camera track stopped:', track.kind);
                    });
                    this.stream = null;
                }
                
                if (this.video.srcObject) {
                    this.video.srcObject = null;
                }
                
                this.stopPoseDetection();
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('togglePoseBtn').disabled = true;
                
                this.updateStatus('videoStatus', 'Camera stopped');
                this.updateStatus('poseStatus', 'Camera needed for pose detection');
            }

            async togglePoseDetection() {
                if (this.isDetecting) {
                    this.stopPoseDetection();
                } else {
                    await this.startPoseDetection();
                }
            }

            async startPoseDetection() {
                try {
                    this.updateStatus('poseStatus', 'Loading AI model...', 'loading');
                    
                    // Load PoseNet model
                    this.net = await posenet.load({
                        architecture: 'MobileNetV1',
                        outputStride: 16,
                        inputResolution: { width: 640, height: 480 },
                        multiplier: 0.75
                    });
                    
                    this.isDetecting = true;
                    document.getElementById('togglePoseBtn').textContent = 'Stop Pose Detection';
                    document.getElementById('togglePoseBtn').className = 'btn btn-secondary';
                    
                    this.updateStatus('poseStatus', 'AI pose detection active', 'active');
                    document.getElementById('poseInfo').style.display = 'block';
                    
                    this.detectPose();
                    
                } catch (error) {
                    console.error('Error loading pose model:', error);
                    this.updateStatus('poseStatus', 'Failed to load AI model', 'error');
                }
            }

            stopPoseDetection() {
                this.isDetecting = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                
                document.getElementById('togglePoseBtn').textContent = 'Start Pose Detection';
                document.getElementById('togglePoseBtn').className = 'btn btn-success';
                
                this.updateStatus('poseStatus', 'Pose detection stopped');
                document.getElementById('poseInfo').style.display = 'none';
                
                // Reset avatar to default pose
                this.avatar.poses = null;
                this.drawAvatar();
            }

            async detectPose() {
                if (!this.isDetecting || !this.net) return;
                
                try {
                    const pose = await this.net.estimateSinglePose(this.video, {
                        flipHorizontal: true,
                        decodingMethod: 'single-person'
                    });
                    
                    this.avatar.poses = pose;
                    this.updatePoseInfo(pose);
                    this.drawAvatar();
                    
                } catch (error) {
                    console.error('Pose detection error:', error);
                }
                
                this.animationId = requestAnimationFrame(() => this.detectPose());
            }

            updatePoseInfo(pose) {
                const confidence = Math.round(pose.score * 100);
                const keypointsCount = pose.keypoints.filter(kp => kp.score > 0.5).length;
                
                document.getElementById('poseConfidence').textContent = confidence + '%';
                document.getElementById('confidenceFill').style.width = confidence + '%';
                document.getElementById('keypointsCount').textContent = keypointsCount;
                document.getElementById('avatarStatus').textContent = confidence > 30 ? 'Mirroring' : 'Searching';
            }

            drawAvatar() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw background grid
                this.drawGrid();
                
                if (this.avatar.poses && this.avatar.poses.score > 0.3) {
                    this.drawPoseAvatar();
                } else {
                    this.drawDefaultAvatar();
                }
            }

            drawGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                
                const gridSize = 30;
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            drawPoseAvatar() {
                const pose = this.avatar.poses;
                const keypoints = pose.keypoints;
                
                // Scale factors to fit canvas
                const scaleX = this.canvas.width / 640;
                const scaleY = this.canvas.height / 480;
                
                // Draw skeleton
                this.ctx.strokeStyle = this.avatar.color;
                this.ctx.lineWidth = 4;
                this.ctx.lineCap = 'round';
                
                // Define skeleton connections
                const connections = [
                    ['leftShoulder', 'rightShoulder'],
                    ['leftShoulder', 'leftElbow'],
                    ['leftElbow', 'leftWrist'],
                    ['rightShoulder', 'rightElbow'],
                    ['rightElbow', 'rightWrist'],
                    ['leftShoulder', 'leftHip'],
                    ['rightShoulder', 'rightHip'],
                    ['leftHip', 'rightHip'],
                    ['leftHip', 'leftKnee'],
                    ['leftKnee', 'leftAnkle'],
                    ['rightHip', 'rightKnee'],
                    ['rightKnee', 'rightAnkle'],
                    ['nose', 'leftEye'],
                    ['nose', 'rightEye'],
                    ['leftEye', 'leftEar'],
                    ['rightEye', 'rightEar']
                ];
                
                // Draw connections
                connections.forEach(([partA, partB]) => {
                    const pointA = keypoints.find(kp => kp.part === partA);
                    const pointB = keypoints.find(kp => kp.part === partB);
                    
                    if (pointA && pointB && pointA.score > 0.5 && pointB.score > 0.5) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(pointA.position.x * scaleX, pointA.position.y * scaleY);
                        this.ctx.lineTo(pointB.position.x * scaleX, pointB.position.y * scaleY);
                        this.ctx.stroke();
                    }
                });
                
                // Draw keypoints
                this.ctx.fillStyle = '#FF6B6B';
                keypoints.forEach(keypoint => {
                    if (keypoint.score > 0.5) {
                        this.ctx.beginPath();
                        this.ctx.arc(
                            keypoint.position.x * scaleX,
                            keypoint.position.y * scaleY,
                            6,
                            0,
                            Math.PI * 2
                        );
                        this.ctx.fill();
                    }
                });
                
                // Draw head
                const nose = keypoints.find(kp => kp.part === 'nose');
                if (nose && nose.score > 0.5) {
                    this.ctx.fillStyle = 'rgba(78, 205, 196, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.arc(
                        nose.position.x * scaleX,
                        nose.position.y * scaleY,
                        25,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.fill();
                }
            }

            drawDefaultAvatar() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Draw default stick figure
                this.ctx.strokeStyle = this.avatar.color;
                this.ctx.lineWidth = 4;
                this.ctx.lineCap = 'round';
                
                // Head
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY - 60, 25, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Body
                this.ctx.beginPath();
                this.ctx.moveTo(centerX, centerY - 35);
                this.ctx.lineTo(centerX, centerY + 40);
                this.ctx.stroke();
                
                // Arms
                this.ctx.beginPath();
                this.ctx.moveTo(centerX - 40, centerY - 10);
                this.ctx.lineTo(centerX + 40, centerY - 10);
                this.ctx.stroke();
                
                // Legs
                this.ctx.beginPath();
                this.ctx.moveTo(centerX, centerY + 40);
                this.ctx.lineTo(centerX - 30, centerY + 80);
                this.ctx.moveTo(centerX, centerY + 40);
                this.ctx.lineTo(centerX + 30, centerY + 80);
                this.ctx.stroke();
                
                // Add pulsing effect
                const time = Date.now() * 0.003;
                const pulse = Math.sin(time) * 0.1 + 1;
                this.ctx.globalAlpha = pulse;
                
                // Draw glow effect
                this.ctx.shadowColor = this.avatar.color;
                this.ctx.shadowBlur = 20;
                this.ctx.stroke();
                
                this.ctx.globalAlpha = 1;
                this.ctx.shadowBlur = 0;
            }

            updateStatus(elementId, message, type = '') {
                const element = document.getElementById(elementId);
                element.textContent = message;
                element.className = `status ${type}`;
            }
        }

        // Initialize the application
        window.addEventListener('load', () => {
            new AvatarMirror();
        });
    </script>
</body>
</html>
